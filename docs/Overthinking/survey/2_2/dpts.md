结论：**DPTS（Dynamic Parallel Tree Search）**是一种**置信度驱动的并行树搜索**，在推理期动态分配计算：只保留高置信分支继续扩展，低置信分支**及时截断**；并用**增量式 KV‑cache**与**按显存自适应的并行宽度**降低内存与计算开销。目标是在接近 BoN/树搜精度的同时显著省算。

# 机制

* **并行性精简（Parallelism Streamline）**：仅存储**增量 KV**并**按可用显存动态调节扩展节点数**，提升吞吐并控内存。
* **搜索与转移（Search & Transition）**：用**置信度**在“探索/利用”间切换；**不确定路径即时剪枝**，把预算让给更有希望的分支。
* **核心思想**：**早停+路由**。越早识别“差”路径，越少无效解码。

# 置信度信号（示例）

* 语义熵、奖励/过程奖励模型分数，或二者结合（Certaindex 思路，可量化“继续思考是否还会改变答案”）。
* 阈值或排名驱动的保留/淘汰策略，用于**逐轮筛选**并行分支。

# 推理流程（简化）

1. **并行起步**：从根节点采样若干分支，缓存各自增量 KV。
2. **局部解码 → 打分**：每前进 Δt token，计算分支置信度。
3. **剪枝/扩展**：丢弃低分分支；根据显存余量动态设定新的并行宽度并继续扩展高分分支。
4. **收敛/停止**：到预算或置信度充分高时终止，输出最优分支。

# 与相近方法

* **FastMCTS**：同属置信度驱动，但面向数据合成与难度自适应扩展；DPTS更强调**推理期**的并行与增量 KV 管理。
* **ST‑BoN**：基于隐表示一致性的**早停 BoN**，不必奖励模型；DPTS是**树搜范式**且显式并行调度。
* **SR（Speculative Rejection）**：批量采样+奖励早淘汰；DPTS把“淘汰”嵌入**树结构与置信转移**，更像结构化搜索。

# 何时用

* 任务难度不均，BoN/SC 成本过高。
* 有可用的置信信号（语义熵、PRM、Verifier）。
* 需要**显存自适应**的并行推理。

# 实操要点

* **Δt（评估间隔）**：过短噪声大，过长浪费算力。
* **保留比例**：保守更稳，激进更省算。
* **KV 复用**：严格增量化，避免全量重算。
* **停止规则**：固定预算+置信阈值联合。
* **税则**：把 DPTS 归入“Dynamic Reasoning Paradigm”，与 SR、ST‑BoN 等同类。

# 伪代码（骨架）

```
S = init_parallel(branches=B0, kv=incremental)
while budget_ok:
  extend(S, Δt)                     # 局部解码
  conf = score_confidence(S)        # 语义熵/PRM/Verifier
  S = keep_top_k(S, conf, k(mem))   # 显存感知的并行宽度
  if max(conf) >= τ or time_up(): break
return select_best(S)
```

一句话：**DPTS = 置信度驱动的动态并行树搜 + 增量 KV 管理 + 显存自适应宽度**，把计算集中到“最有希望”的路径上，减少无效思考。
